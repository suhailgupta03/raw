package tests

import (
	"encoding/json"
	"github.com/stretchr/testify/assert"
	"raw/src/api"
	"raw/src/core"
	"raw/src/parser"
	"raw/src/structs"
	"runtime"
	"sync"
	"testing"
)

type SingleRecord map[string]interface{}
type MultipleRecords []SingleRecord

type Base struct {
	Schema structs.Schema `json:"schema"`
	Name   string         `json:"name"`
}

type TestDataWithSingleRecord struct {
	Base
	Data SingleRecord `json:"data"`
}

type TestDataWithMultipleRecords struct {
	Base
	Data MultipleRecords `json:"data"`
}

var (
	testConfig = InitTestConfig()
)

func getDataForWriteTest(t *testing.T, fileData interface{}) {
	_, filename, _, _ := runtime.Caller(0)
	data := GetTestFileData(t, filename)
	json.Unmarshal(data, &fileData)
}

func TestCreateRecord(t *testing.T) {
	testRecord := &TestDataWithSingleRecord{}
	getDataForWriteTest(t, testRecord)
	parseError, parseSuccess := parser.Parse(testRecord.Schema)
	assert.True(t, parseSuccess, "Parse function should succeed")
	assert.Equal(t, "", parseError.Message)

	raw := api.Raw{Root: testConfig.DatabaseRoot}
	model := raw.DefineModel(api.Model{
		Name:   testRecord.Name,
		Schema: testRecord.Schema,
	})

	createChannel := model.Create(api.Create{
		Values: testRecord.Data,
	})

	createResponse := <-createChannel
	createdRecord := createResponse.Data
	cErr := createResponse.Err
	assert.True(t, cErr == nil, "Record must be created")
	assert.Equal(t, testRecord.Data["batch_id"], createdRecord["batch_id"])
}

func TestCreateRecordWithoutPrimaryKey(t *testing.T) {
	testRecord := &TestDataWithSingleRecord{}
	getDataForWriteTest(t, testRecord)
	parseError, parseSuccess := parser.Parse(testRecord.Schema)
	assert.True(t, parseSuccess, "Parse function should succeed")
	assert.Equal(t, "", parseError.Message)

	raw := api.Raw{Root: testConfig.DatabaseRoot}
	model := raw.DefineModel(api.Model{
		Name:   testRecord.Name,
		Schema: testRecord.Schema,
	})

	createChannel := model.Create(api.Create{
		Values: testRecord.Data,
	})
	createResponse := <-createChannel
	createdRecord := createResponse.Data
	cErr := createResponse.Err
	assert.True(t, cErr == nil, "Record must be created")
	assert.True(t, createdRecord[parser.DefaultPrimaryKey] != nil, "Primary key must be generated by the system")
}

func TestCreateRecordWithDuplicatePrimaryKey(t *testing.T) {
	testRecord := &TestDataWithSingleRecord{}
	getDataForWriteTest(t, &testRecord)
	parseError, parseSuccess := parser.Parse(testRecord.Schema)
	assert.True(t, parseSuccess, "Parse function should succeed")
	assert.Equal(t, "", parseError.Message)

	raw := api.Raw{Root: testConfig.DatabaseRoot}
	model := raw.DefineModel(api.Model{
		Name:   testRecord.Name,
		Schema: testRecord.Schema,
	})

	createChannel := model.Create(api.Create{
		Values: testRecord.Data,
	})
	createResponse := <-createChannel
	createdRecord := createResponse.Data
	cErr := createResponse.Err
	assert.True(t, cErr == nil, "Record must be created")
	assert.True(t, createdRecord["batch_id"] == testRecord.Data["batch_id"], "Record must be created the first time")

	duplicateRecordChannel := model.Create(api.Create{
		Values: testRecord.Data,
	})

	duplicateCreateResponse := <-duplicateRecordChannel
	duplicateRecord := duplicateCreateResponse.Data
	drErr := duplicateCreateResponse.Err

	assert.True(t, drErr != nil, "Record must not be created")
	assert.Contains(t, drErr.Error(), core.PrimaryKeyConstraintViolated)
	assert.Nil(t, duplicateRecord, "Duplicate record must be nil")
}

// This test case tests the concurrency of the write method by
// making concurrent calls to the write method. Different calls
// competing to write to the disk can lead to scenario where
// previous record gets overwritten by the new record. This is what
// this test case tests.
func TestCreateRecordWithConcurrentWrites(t *testing.T) {
	testRecord := &TestDataWithMultipleRecords{}
	getDataForWriteTest(t, testRecord)
	const oneLakh = uint32(100000)
	// Create a data set of 1 lakh records
	for i := uint32(len(testRecord.Data)) + 1; i < oneLakh+1; i++ {
		singleRecord := make(SingleRecord)
		singleRecord["name"] = testRecord.Data[0]["name"]
		singleRecord["country_of_origin"] = testRecord.Data[0]["country_of_origin"]
		singleRecord["quantity"] = testRecord.Data[0]["quantity"]
		singleRecord["batch_id"] = i
		testRecord.Data = append(testRecord.Data, singleRecord)
	}

	raw := api.Raw{Root: testConfig.DatabaseRoot}
	model := raw.DefineModel(api.Model{
		Name:   testRecord.Name,
		Schema: testRecord.Schema,
	})

	var totalRecordsCreated uint32
	var totalErrorsRecorded uint32

	var wg sync.WaitGroup
	var m sync.Mutex

	channelSlice := make([]chan api.CreateResponse, 0)

	f := func() {
		defer wg.Done()
		for i := uint32(0); i < oneLakh; i++ {
			c := model.Create(api.Create{
				Values: testRecord.Data[i],
			})

			m.Lock()
			channelSlice = append(channelSlice, c)
			m.Unlock()
		}

	}

	wg.Add(1)
	go f()
	wg.Add(1)
	go f()
	wg.Wait()

	for i := uint32(0); i < uint32(len(channelSlice)); i++ {
		func() {
			defer close(channelSlice[i])
			createResponse := <-channelSlice[i]
			err := createResponse.Err
			if err == nil {
				totalRecordsCreated += 1
			} else {
				totalErrorsRecorded += 1
			}
		}()
	}
	assert.Equal(t, oneLakh, totalRecordsCreated, "Should be able to handle concurrent writes")
	assert.Equal(t, oneLakh, totalErrorsRecorded, "Thread safe write create function must not truncate an existing record")

}
